<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Zhentao Shi">

<title>Least Squares</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="03_OLS_files/libs/clipboard/clipboard.min.js"></script>
<script src="03_OLS_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="03_OLS_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="03_OLS_files/libs/quarto-html/popper.min.js"></script>
<script src="03_OLS_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="03_OLS_files/libs/quarto-html/anchor.min.js"></script>
<link href="03_OLS_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="03_OLS_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="03_OLS_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="03_OLS_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="03_OLS_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Least Squares</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Zhentao Shi </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>Notation: <span class="math inline">\(y_{i}\)</span> is a scalar, and <span class="math inline">\(x_{i}=\left(x_{i1},\ldots,x_{ip}\right)'\)</span> is a <span class="math inline">\(p\times1\)</span> vector. <span class="math inline">\(Y=\left(y_{1},\ldots,y_{n}\right)'\)</span> is an <span class="math inline">\(n\times1\)</span> vector, and <span class="math display">\[X=\left[\begin{array}{c}
x_{1}'\\
x_{2}'\\
\vdots\\
x_{n}'
\end{array}\right]=\left[\begin{array}{cccc}
x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1p}\\
x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2p}\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
x_{n1} &amp; x_{22} &amp; \cdots &amp; x_{np}
\end{array}\right]\]</span> is an <span class="math inline">\(n\times p\)</span> matrix. <span class="math inline">\(I_{n}\)</span> is an <span class="math inline">\(n\times n\)</span> identity matrix.</p>
<p>Ordinary least squares (OLS) is the most basic estimation technique in econometrics. It is simple and transparent. Understanding it thoroughly paves the way to study more sophisticated linear estimators. Moreover, many nonlinear estimators resemble the behavior of linear estimators in a neighborhood of the true value. In this lecture, we learn a series of facts from the linear algebra operation.</p>
<section id="estimator" class="level2">
<h2 class="anchored" data-anchor-id="estimator">Estimator</h2>
<p>As we have learned from the linear projection model, the projection coefficient <span class="math inline">\(\beta\)</span> in the regression <span id="eq-pop-OLS"><span class="math display">\[
\begin{aligned}y &amp; =x'\beta+e\end{aligned}
\tag{1}\]</span></span> can be written as <span class="math display">\[\begin{equation}
\beta=\left(E\left[xx'\right]\right)^{-1}E\left[xy\right].\label{eq:pop_OLS}
\end{equation}\]</span> We draw a pair of <span class="math inline">\(\left(y,x\right)\)</span> from the joint distribution, and we mark it as <span class="math inline">\(\left(y_{i},x_{i}\right)\)</span> for <span class="math inline">\(i=1,\ldots,n\)</span> repeated experiments. We possess a <em>sample</em> <span class="math inline">\(\left(y_{i},x_{i}\right)_{i=1}^{n}\)</span>.</p>
<div class="rem">
<p><em>1.1</em>. Is <span class="math inline">\(\left(y_{i},x_{i}\right)\)</span> random or deterministic? Before we make the observation, they are treated as random variables whose realized values are uncertain. <span class="math inline">\(\left(y_{i},x_{i}\right)\)</span> is treated as random when we talk about statistical properties — statistical properties of a fixed number is meaningless. After we make the observation, they become deterministic values which cannot vary anymore.</p>
</div>
<div class="rem">
<p><em>1.2</em>. In reality, we have at hand fixed numbers (more recently, words, photos, audio clips, video clips, etc., which can all be represented in digital formats with 0 and 1) to feed into a computational operation, and the operation will return one or some numbers. All statistical interpretation about these numbers are drawn from the probabilistic thought experiments. A <em>thought experiment</em> is an academic jargon for a <em>story</em> in plain language. Under the axiomatic approach of probability theory, such stories are mathematical consistent and coherent. But mathematics is a tautological system, not science. The scientific value of a probability model depends on how close it is to the <em>truth</em> or implications of the truth. In this course, we suppose that the data are generated from some mechanism, which is taken as the truth. In the linear regression model for example, the joint distribution of <span class="math inline">\(\left(y,x\right)\)</span> is the truth, while we are interested in the linear projection coefficient <span class="math inline">\(\beta\)</span>, which is an implication of the truth as in (<a href="#eq-pop-OLS" class="quarto-xref">Equation&nbsp;1</a>). Probabilists suppose there is a dragon and try to tell the dragon’s behaviors. Statisticians observe many snakes on earth, and try to tell what a dragon looks like.</p>
</div>
<p>The sample mean is a natural estimator of the population mean. Replace the population mean <span class="math inline">\(E\left[\cdot\right]\)</span> in(<a href="#eq-pop-OLS" class="quarto-xref">Equation&nbsp;1</a>) by the sample mean <span class="math inline">\(\frac{1}{n}\sum_{i=1}^{n}\cdot\)</span>, and the resulting estimator is <span class="math display">\[\widehat{\beta}=\left(\frac{1}{n}\sum_{i=1}^{n}x_{i}x_{i}'\right)^{-1}\frac{1}{n}\sum_{i=1}^{n}x_{i}y_{i}=\left(\frac{X'X}{n}\right)^{-1}\frac{X'y}{n}=\left(X'X\right)^{-1}X'y\]</span> if <span class="math inline">\(X'X\)</span> is invertible. This is one way to motivate the OLS estimator.</p>
<section id="simulation-example" class="level3">
<h3 class="anchored" data-anchor-id="simulation-example">Simulation example</h3>
<p>The following code simulates a small dataset and computes OLS using the closed-form formula <span class="math inline">\(\widehat\beta=(X'X)^{-1}X'Y\)</span> (and compares it to <code>lstsq</code>).</p>
<div id="sim-ols" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(<span class="dv">5150</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="dv">3</span>  <span class="co"># intercept + 2 regressors</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> rng.normal(size<span class="op">=</span>n)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> rng.normal(size<span class="op">=</span>n)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.column_stack([np.ones(n), x1, x2])</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>beta_true <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="op">-</span><span class="fl">2.0</span>, <span class="fl">0.5</span>])</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>eps <span class="op">=</span> rng.normal(scale<span class="op">=</span><span class="fl">0.5</span>, size<span class="op">=</span>n)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> X <span class="op">@</span> beta_true <span class="op">+</span> eps</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>beta_hat <span class="op">=</span> np.linalg.inv(X.T <span class="op">@</span> X) <span class="op">@</span> (X.T <span class="op">@</span> y)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>beta_hat_lstsq, <span class="op">*</span>_ <span class="op">=</span> np.linalg.lstsq(X, y, rcond<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>y_hat <span class="op">=</span> X <span class="op">@</span> beta_hat</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>e_hat <span class="op">=</span> y <span class="op">-</span> y_hat</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>np.set_printoptions(precision<span class="op">=</span><span class="dv">3</span>, suppress<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"X:</span><span class="ch">\n</span><span class="st">"</span>, X)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"y:</span><span class="ch">\n</span><span class="st">"</span>, y)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"beta_true:"</span>, beta_true)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"beta_hat (formula):"</span>, beta_hat)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"beta_hat (lstsq)  :"</span>, beta_hat_lstsq)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"X' e_hat (should be ~0):"</span>, X.T <span class="op">@</span> e_hat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>X:
 [[ 1.     1.384 -0.543]
 [ 1.    -0.27  -0.918]
 [ 1.     2.119  0.419]
 [ 1.     0.899  0.068]
 [ 1.    -1.594  0.278]
 [ 1.     0.739  0.167]
 [ 1.    -0.215  0.855]
 [ 1.     0.318 -1.6  ]
 [ 1.    -1.363  0.154]
 [ 1.    -0.864  1.852]]
y:
 [-1.434  0.547 -3.529 -0.613  4.608 -0.229  1.237  0.461  4.601  3.5  ]
beta_true: [ 1.  -2.   0.5]
beta_hat (formula): [ 1.146 -2.129  0.197]
beta_hat (lstsq)  : [ 1.146 -2.129  0.197]
X' e_hat (should be ~0): [ 0.  0. -0.]</code></pre>
</div>
</div>
</section>
</section>
<section id="geometry-of-ols" class="level2">
<h2 class="anchored" data-anchor-id="geometry-of-ols">Geometry of OLS</h2>
<p>There is natural geometry interpretation of the OLS estimator in a <span class="math inline">\(n\)</span>-dimensional Euclidean space. Notice <span class="math inline">\(\mathcal{X}=\left\{ Xb:b\in\mathbb{R}^{p}\right\}\)</span> is the linear space spanned by the <span class="math inline">\(p\)</span> columns of <span class="math inline">\(X=\left[X_{\cdot1},\ldots,X_{\cdot p}\right]\)</span>, which is of <span class="math inline">\(p\)</span>-dimension if the columns are linearly independent. The OLS estimator is the minimizer of <span class="math inline">\(\min_{b\in\mathbb{R}^{p}}\left\Vert Y-Xb\right\Vert\)</span> (Square the Euclidean norm or not does not change the minimizer because <span class="math inline">\(a^{2}\)</span> is a monotonic transformation for <span class="math inline">\(a\geq 0\)</span>). In other words, <span class="math inline">\(X\widehat{\beta}\)</span> is the point in <span class="math inline">\(\mathcal{X}\)</span> such that it is the closest to the vector <span class="math inline">\(Y\)</span> in terms of the Euclidean norm.</p>
<p>Define <span class="math display">\[\widehat{Y} = X \widehat{\beta} = X (X'X)^{-1}X' Y = P_X Y,\]</span> where <span class="math inline">\(P_X = X (X'X)^{-1}X'\)</span> is the projector to the columns space of <span class="math inline">\(X\)</span>. One the other hand, define <span class="math display">\[\widehat{e} = Y - \widehat{Y} = (I_n - P_X) Y = P_X^\perp Y,\]</span> where <span class="math inline">\(P_X^\perp\)</span> is the projector to the null space of <span class="math inline">\(X\)</span>. Since the null space and the column space are orthogonal, it is easy to verify that <span class="math display">\[\left\langle X\widehat{\beta},\widehat{e}\right\rangle =\widehat{\beta}'X'\widehat{e}=0_{p}^{\prime}.\]</span> The Pythagorean theorem implies <span class="math display">\[\left\Vert Y\right\Vert ^{2}=\Vert X\widehat{\beta}\Vert^{2}+\left\Vert \widehat{e}\right\Vert ^{2}.\]</span></p>
<div id="ols-pythag" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>y_norm_sq <span class="op">=</span> np.linalg.norm(y) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>yhat_norm_sq <span class="op">=</span> np.linalg.norm(y_hat) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>e_norm_sq <span class="op">=</span> np.linalg.norm(e_hat) <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"||Y||^2:"</span>, y_norm_sq)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"||X b_hat||^2 + ||e_hat||^2:"</span>, yhat_norm_sq <span class="op">+</span> e_norm_sq)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>||Y||^2: 71.63717002686542
||X b_hat||^2 + ||e_hat||^2: 71.63717002686539</code></pre>
</div>
</div>
<p>If <span class="math inline">\(X\)</span> has full column rank and we use a SVD <span class="math display">\[X=\underset{(n\times n)}{U} \underset{(p\times p)}{S} \underset{(p\times p)}{V}'\]</span> where <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> have orthonormal columns and <span class="math inline">\(S\)</span> is diagonal with the <span class="math inline">\(p\)</span> singular values of <span class="math inline">\(X\)</span>, then the fitted values can be written as <span class="math display">\[\widehat{Y}=X\widehat{\beta}=X(X'X)^{-1}X'Y=UU'Y.\]</span> In other words, in terms of in-sample fitting, OLS using regressors <span class="math inline">\(X\)</span> is equivalent to regressing <span class="math inline">\(Y\)</span> on the orthonormal basis <span class="math inline">\(U\)</span> for the column space of <span class="math inline">\(X\)</span> (the two procedures have the same projection <span class="math inline">\(\widehat{Y}\)</span>). The corresponding coefficients satisfy <span class="math inline">\(\widehat{\beta}=VS^{-1}U'Y\)</span>.</p>
</section>
<section id="fwl-theorem" class="level2">
<h2 class="anchored" data-anchor-id="fwl-theorem">FWL Theorem</h2>
<p>The Frisch-Waugh-Lovell (FWL) theorem is an algebraic fact about the formula of a subvector of the OLS estimator. Decompose <span class="math inline">\(X = (X_1, X_2)\)</span> where <span class="math inline">\(X_1\)</span> is <span class="math inline">\(n\times (p-1)\)</span> matrix and <span class="math inline">\(X_2\)</span> is an <span class="math inline">\(n\times 1\)</span> vector, so that <span id="eq-x1x2"><span class="math display">\[\begin{equation}
Y = X_1 \widehat{\beta}_1 + X_2 \widehat{\beta}_2 + \widehat{e}.
\end{equation}
\tag{2}\]</span></span> To find <span class="math inline">\(\widehat{\beta}_2\)</span>, we first decompose <span class="math inline">\(X_2\)</span> into its projection onto <span class="math inline">\(\mathrm{span}(X_1)\)</span> and its projection residual: <span class="math display">\[X_2 = P_1 X_2 + P_1^\perp X_2,\]</span> where <span class="math inline">\(P_1 = X_1 (X_1' X_1)^{-1} X_1'\)</span> is the projector onto <span class="math inline">\(\mathrm{span}(X_1)\)</span> and <span class="math inline">\(P_1^\perp=I_n-P_1\)</span>. Pre-multiply <span class="math inline">\(P_1^\perp\)</span> on both sides of (<a href="#eq-x1x2" class="quarto-xref">Equation&nbsp;2</a>), we have <span class="math display">\[P_1^\perp Y = P_1^\perp X_1 \widehat{\beta}_1 +  P_1^\perp X_2 \widehat{\beta}_2+P_1^\perp\widehat{e}
= P_1^\perp X_2 \widehat{\beta}_2+ \widehat{e}\]</span> since <span class="math inline">\(P_1^\perp X_1=0\)</span> and <span class="math inline">\(P_1^\perp \widehat{e} = \widehat{e}\)</span>.</p>
<p>Because <span class="math inline">\(\tilde{X}_2 = P_1^\perp X_2\)</span> is orthogonal to <span class="math inline">\(\mathrm{span}(X_1)\)</span>, the coefficient on <span class="math inline">\(X_2\)</span> in the full regression is pinned down entirely by <span class="math inline">\(\tilde{X}_2\)</span>: <span class="math display">\[\widehat{\beta}_2=(\tilde{X}_2'\tilde{X}_2)^{-1}\tilde{X}_2' Y
=(X_2'P_1^\perp X_2)^{-1}X_2'P_1^\perp Y.\]</span></p>
<div id="sim-ols-fwl" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>X1 <span class="op">=</span> X[:, <span class="dv">0</span>:<span class="dv">2</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>X2 <span class="op">=</span> X[:,<span class="dv">2</span>]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>beta_full, <span class="op">*</span>_ <span class="op">=</span> np.linalg.lstsq(X, y, rcond<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>beta2_full <span class="op">=</span> beta_full[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>P1 <span class="op">=</span> X1 <span class="op">@</span> np.linalg.inv(X1.T <span class="op">@</span> X1) <span class="op">@</span> X1.T</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>M1 <span class="op">=</span> np.eye(n) <span class="op">-</span> P1</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>X2_tilde <span class="op">=</span> M1 <span class="op">@</span> X2</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>y_tilde <span class="op">=</span> M1 <span class="op">@</span> y</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>beta2_fwl <span class="op">=</span> (X2_tilde <span class="op">@</span> y_tilde) <span class="op">/</span> (X2_tilde <span class="op">@</span> X2_tilde)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"beta2 (full):"</span>, beta2_full)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"beta2 (FWL) :"</span>, beta2_fwl)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>beta2 (full): 0.19720250395147088
beta2 (FWL) : 0.19720250395147068</code></pre>
</div>
</div>
</section>
<section id="omitted-variable-bias" class="level2">
<h2 class="anchored" data-anchor-id="omitted-variable-bias">Omitted Variable Bias</h2>
<p>Suppose that researcher A runs a full regression <span class="math inline">\(Y = X_1 \widehat{\beta}_1 + X_2 \widehat{\beta}_2 + \widehat{e}\)</span>. When he sends the data to researcher B, he omits <span class="math inline">\(X_2\)</span> by accident. Research B can only estimated the coefficient for <span class="math inline">\(X_1\)</span>. What would be its different from researcher A’s <span class="math inline">\(\widehat{\beta}_1\)</span>?</p>
<p>Notice in researcher A’s world: <span class="math display">\[\begin{align*}
  Y &amp; = X_1 \widehat{\beta}_1 + X_2 \widehat{\beta}_2 + \widehat{e} \\
    &amp; = X_1 \widehat{\beta}_1 + (P_1X_2+P_1^\perp X_2) \widehat{\beta}_2 + \widehat{e} \\
    &amp; = ( X_1 \widehat{\beta}_1 + P_1X_2 \widehat{\beta}_2 ) + ( P_1^\perp X_2 \widehat{\beta}_2 + \widehat{e}) \\
    &amp; = X_1 (\widehat{\beta}_1 + \widehat{\pi}\widehat{\beta}_2 ) + ( P_1^\perp X_2 \widehat{\beta}_2 + \widehat{e}),
\end{align*}\]</span> where <span class="math inline">\(\widehat{\pi}=(X_1'X_1)^{-1}X_1'X_2.\)</span> In other words, researcher B will obtain the coefficient <span class="math inline">\((\widehat{\beta}_1 + \widehat{\pi}\widehat{\beta}_2 )\)</span> associated with <span class="math inline">\(X_1\)</span>, and his residual is <span class="math inline">\(( P_1^\perp X_2 \widehat{\beta}_2 + \widehat{e})\)</span>.</p>
<p>Intuitively, regressing on <span class="math inline">\(X_1\)</span> only forces the component <span class="math inline">\(P_1X_2=X_1\widehat{\pi}\)</span> to be absorbed by the coefficient on <span class="math inline">\(X_1\)</span>, while the orthogonal component <span class="math inline">\(P_1^\perp X_2 \widehat{\beta}_2\)</span> becomes part of the residual.</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>The derivations above are finite-sample linear algebra in <span class="math inline">\(\mathbb{R}^n\)</span>: <span class="math inline">\(X_1\)</span> and <span class="math inline">\(X_2\)</span> span subspaces of <span class="math inline">\(\mathbb{R}^n\)</span>, and <span class="math inline">\(P_1\)</span> and <span class="math inline">\(P_1^\perp\)</span> are ordinary projection matrices. There are population counterparts of both the FWL theorem and the omitted variable bias formula. In that setting, <span class="math inline">\(Y\)</span> and the components of <span class="math inline">\(X\)</span> are random variables that live in a Hilbert space (typically an <span class="math inline">\(L^2\)</span> space), and “projection” is defined by the linear projection (orthogonality) operator rather than an <span class="math inline">\(n\times n\)</span> matrix. The same logic goes through with population inner products (expectations) replacing sample inner products, but the geometry is more abstract, so we omit the full display.</p>
<p><strong>Historical notes</strong>: Carl Friedrich Gauss (1777–1855) claimed he had come up with the operation of OLS in 1795. With only three data points at hand, Gauss successfully applied his method to predict the location of the dwarf planet Ceres in 1801. While Gauss did not publish the work on OLS until 1809, Adrien-Marie Legendre (1752–1833) presented this method in 1805. Today people tend to attribute OLS to Gauss, assuming that a giant like Gauss had no need to tell a lie to steal Legendre’s discovery.</p>
<p><code>Zhentao Shi. 2026-01-15</code></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>